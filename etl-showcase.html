<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google Tag Manager -->
    <script>
    window.dataLayer = window.dataLayer || [];
    dataLayer.push({
        'pageName': 'ETL Showcase',
        'pageType': 'Portfolio',
        'siteName': 'SiegeStack'
    });
    </script>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KKNXM7TW');</script>
    <!-- End Google Tag Manager -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-D9JTK6CC9J"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-D9JTK6CC9J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="alternate icon" href="/favicon.ico">
    <title>ETL, API, Web Services & Query Excellence | SiegeStack</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Production-grade ETL pipelines, API integrations, web services, and SQL queries with bulletproof error handling. See how SiegeStack builds systems that handle millions of records with zero downtime.">
    <meta name="keywords" content="ETL pipeline, data extraction, data transformation, data loading, SQL queries, API integration, REST API, webhook handling, rate limiting, web services, Express.js, Node.js, authentication, middleware, error handling, data engineering, production-ready code">
    <meta name="author" content="SiegeStack">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://siegestack.com/etl-showcase">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://siegestack.com/etl-showcase">
    <meta property="og:title" content="ETL, API, Web Services & Query Excellence | SiegeStack">
    <meta property="og:description" content="Production-grade ETL pipelines, API integrations, and web services with bulletproof error handling.">
    <meta property="og:image" content="https://siegestack.com/og-image.png">

    <meta name="theme-color" content="#0a192f">

    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "TechArticle",
        "headline": "ETL, API, Web Services & Query Excellence - Production-Grade Code Examples",
        "description": "Production-grade ETL pipelines, API integrations, web services, and SQL queries with bulletproof error handling. Code examples for data extraction, transformation, loading, REST clients, webhooks, rate limiting, Express servers, authentication, and health monitoring.",
        "author": {
            "@type": "Organization",
            "name": "SiegeStack",
            "url": "https://siegestack.com"
        },
        "publisher": {
            "@type": "Organization",
            "name": "SiegeStack",
            "url": "https://siegestack.com"
        },
        "datePublished": "2026-01-25",
        "dateModified": "2026-01-25",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://siegestack.com/etl-showcase"
        },
        "about": [
            "ETL Pipeline Development",
            "API Integration",
            "Web Services Development",
            "SQL Query Optimization",
            "Error Handling",
            "Data Engineering",
            "Node.js Development"
        ],
        "keywords": "ETL, API integration, web services, SQL queries, data pipeline, error handling, webhooks, rate limiting, Express.js, authentication, middleware"
    }
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --navy-dark: #0a192f;
            --navy: #112240;
            --navy-light: #1d3557;
            --blue-accent: #64ffda;
            --blue-bright: #57cbff;
            --slate: #8892b0;
            --light-slate: #a8b2d1;
            --lightest-slate: #ccd6f6;
            --white: #e6f1ff;
            --red-soft: #ff6b6b;
            --yellow-soft: #ffd93d;
            --green-soft: #6bcb77;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--navy-dark);
            color: var(--lightest-slate);
            line-height: 1.6;
        }

        /* Navigation */
        nav {
            position: fixed;
            top: 0;
            width: 100%;
            background: rgba(10, 25, 47, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(100, 255, 218, 0.1);
        }

        .nav-logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--white);
            text-decoration: none;
            letter-spacing: -1px;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .nav-links a {
            color: var(--light-slate);
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s;
        }

        .nav-links a:hover {
            color: var(--blue-accent);
        }

        .btn {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s;
            cursor: pointer;
            border: none;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: var(--blue-accent);
            color: var(--navy-dark);
        }

        .btn-primary:hover {
            background: var(--blue-bright);
            transform: translateY(-2px);
        }

        .mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            color: var(--light-slate);
            font-size: 1.5rem;
            cursor: pointer;
        }

        /* Main Content */
        .showcase-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 7rem 2rem 4rem;
        }

        /* Header */
        .showcase-header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .showcase-header h1 {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--blue-accent), var(--blue-bright));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .showcase-header p {
            font-size: 1.2rem;
            color: var(--slate);
        }

        /* Value Propositions */
        .value-props {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2.5rem;
        }

        .value-prop-card {
            background: var(--navy);
            border: 1px solid rgba(100, 255, 218, 0.1);
            border-radius: 8px;
            padding: 1.75rem;
            text-align: center;
            transition: all 0.2s;
        }

        .value-prop-card:hover {
            border-color: rgba(100, 255, 218, 0.3);
            transform: translateY(-2px);
        }

        .value-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 1rem;
            background: rgba(100, 255, 218, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .value-icon svg {
            width: 24px;
            height: 24px;
            color: var(--blue-accent);
        }

        .value-prop-card h3 {
            color: var(--white);
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
        }

        .value-prop-card p {
            color: var(--slate);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Showcase Intro */
        .showcase-intro {
            background: rgba(100, 255, 218, 0.05);
            border-left: 3px solid var(--blue-accent);
            padding: 1.25rem 1.5rem;
            margin-bottom: 2.5rem;
            border-radius: 0 8px 8px 0;
        }

        .showcase-intro p {
            color: var(--light-slate);
            font-size: 0.95rem;
            margin: 0;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            border-bottom: 1px solid rgba(100, 255, 218, 0.2);
            padding-bottom: 0;
        }

        .tab-btn {
            background: none;
            border: none;
            color: var(--slate);
            font-size: 1rem;
            font-weight: 600;
            padding: 1rem 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tab-btn:hover {
            color: var(--light-slate);
        }

        .tab-btn.active {
            color: var(--blue-accent);
            border-bottom-color: var(--blue-accent);
        }

        .tab-btn svg {
            width: 20px;
            height: 20px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Pipeline Stage Cards */
        .pipeline-stages {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stage-card {
            background: var(--navy);
            border: 1px solid rgba(100, 255, 218, 0.1);
            border-radius: 8px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .stage-card:hover {
            border-color: rgba(100, 255, 218, 0.3);
        }

        .stage-card.active {
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.15), rgba(87, 203, 255, 0.1));
            border-color: var(--blue-accent);
            box-shadow: 0 4px 20px rgba(100, 255, 218, 0.15);
        }

        .stage-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .stage-card h3 {
            color: var(--white);
            font-size: 1.1rem;
        }

        .stage-card-header svg {
            width: 20px;
            height: 20px;
            color: var(--blue-accent);
        }

        .stage-card p {
            color: var(--slate);
            font-size: 0.9rem;
        }

        /* Code Block */
        .code-container {
            background: var(--navy);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 2rem;
            border: 1px solid rgba(100, 255, 218, 0.1);
        }

        .code-header {
            background: var(--navy-dark);
            padding: 0.75rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(100, 255, 218, 0.1);
        }

        .code-filename {
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 0.85rem;
            color: var(--slate);
        }

        .code-badge {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.75rem;
            color: var(--green-soft);
        }

        .code-badge svg {
            width: 14px;
            height: 14px;
        }

        .code-block {
            padding: 1.5rem;
            overflow-x: auto;
        }

        .code-block pre {
            margin: 0;
            font-family: 'SF Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            color: var(--lightest-slate);
            white-space: pre;
        }

        /* Syntax highlighting approximation */
        .code-block .keyword { color: #c792ea; }
        .code-block .function { color: #82aaff; }
        .code-block .string { color: #c3e88d; }
        .code-block .comment { color: #546e7a; }
        .code-block .number { color: #f78c6c; }

        /* Error Handling Section */
        .error-section {
            background: var(--navy);
            border-radius: 8px;
            padding: 1.5rem;
            border: 1px solid rgba(100, 255, 218, 0.1);
        }

        .error-section-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1.25rem;
            font-size: 1.2rem;
            color: var(--white);
        }

        .error-section-title svg {
            width: 24px;
            height: 24px;
            color: var(--yellow-soft);
        }

        .error-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .error-item {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1rem;
            background: var(--navy-dark);
            border-radius: 6px;
        }

        .error-item svg {
            width: 18px;
            height: 18px;
            color: var(--red-soft);
            flex-shrink: 0;
            margin-top: 2px;
        }

        .error-item-content {
            flex: 1;
        }

        .error-type {
            color: var(--red-soft);
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .error-solution {
            color: var(--slate);
            font-size: 0.9rem;
        }

        .error-solution::before {
            content: "â†’ ";
            color: var(--blue-accent);
        }

        /* Query Cards */
        .query-list {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .query-card {
            background: var(--navy);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(100, 255, 218, 0.1);
        }

        .query-card-header {
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.1), rgba(87, 203, 255, 0.05));
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid rgba(100, 255, 218, 0.1);
        }

        .query-card-header h3 {
            color: var(--white);
            font-size: 1.15rem;
            margin-bottom: 0.35rem;
        }

        .query-card-header p {
            color: var(--slate);
            font-size: 0.9rem;
        }

        .query-card .code-block {
            background: var(--navy-dark);
        }

        /* CTA Section */
        .cta-section {
            margin-top: 4rem;
            text-align: center;
            padding: 3rem;
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.08), rgba(87, 203, 255, 0.05));
            border-radius: 12px;
            border: 1px solid rgba(100, 255, 218, 0.15);
        }

        .cta-section h3 {
            font-size: 1.75rem;
            color: var(--white);
            margin-bottom: 0.75rem;
        }

        .cta-section p {
            color: var(--slate);
            margin-bottom: 1.5rem;
            font-size: 1.05rem;
        }

        .cta-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .btn-outline {
            border: 1px solid var(--blue-accent);
            color: var(--blue-accent);
            background: transparent;
        }

        .btn-outline:hover {
            background: rgba(100, 255, 218, 0.1);
        }

        .cta-note {
            font-size: 0.85rem !important;
            color: var(--slate) !important;
            margin-bottom: 0 !important;
            opacity: 0.8;
        }

        /* Footer */
        footer {
            background: var(--navy-dark);
            border-top: 1px solid rgba(100, 255, 218, 0.1);
            padding: 3rem 2rem;
            text-align: center;
            margin-top: 4rem;
        }

        footer p {
            color: var(--slate);
            font-size: 0.9rem;
        }

        footer a {
            color: var(--blue-accent);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .nav-links {
                display: none;
            }

            .mobile-menu-btn {
                display: block;
            }

            .showcase-container {
                padding: 6rem 1rem 2rem;
            }

            .tab-nav {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .tab-btn {
                padding: 0.75rem 1rem;
                font-size: 0.9rem;
                white-space: nowrap;
            }

            .pipeline-stages {
                grid-template-columns: 1fr;
            }

            .code-block pre {
                font-size: 0.75rem;
            }

            .cta-section {
                padding: 2rem 1.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KKNXM7TW"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <!-- Navigation -->
    <nav>
        <a href="/" class="nav-logo">SiegeStack</a>
        <div class="nav-links">
            <a href="/#solutions">Solutions</a>
            <a href="/#process">Process</a>
            <a href="/etl-showcase">ETL Showcase</a>
            <a href="/#schedule" class="btn btn-primary">Get Started</a>
        </div>
        <button class="mobile-menu-btn" aria-label="Menu">&#9776;</button>
    </nav>

    <div class="showcase-container">
        <!-- Header -->
        <div class="showcase-header">
            <h1>Systems That Just Work</h1>
            <p>See how we build software that handles the unexpected, so you don't have to</p>
        </div>

        <!-- Value Proposition Section -->
        <div class="value-props">
            <div class="value-prop-card">
                <div class="value-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                    </svg>
                </div>
                <h3>Bulletproof Reliability</h3>
                <p>Every system we build anticipates failures before they happen. Your data stays safe, your integrations stay connected, and your business keeps running.</p>
            </div>
            <div class="value-prop-card">
                <div class="value-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                </div>
                <h3>Zero Downtime</h3>
                <p>Graceful error recovery means problems get logged and fixed automatically. No 3 AM phone calls, no lost transactions, no angry customers.</p>
            </div>
            <div class="value-prop-card">
                <div class="value-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                        <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                        <line x1="12" y1="22.08" x2="12" y2="12"></line>
                    </svg>
                </div>
                <h3>Scales With You</h3>
                <p>Built to handle millions of records from day one. As your business grows, your systems grow with you - no expensive rewrites needed.</p>
            </div>
        </div>

        <!-- Intro Text -->
        <div class="showcase-intro">
            <p>Below you'll see real examples of how we write code. Not demo projects - actual patterns we use in production. Click through to see how we handle the tricky stuff that separates amateur code from enterprise-grade systems.</p>
        </div>

        <!-- Tab Navigation -->
        <div class="tab-nav">
            <button class="tab-btn active" data-tab="etl">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
                    <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
                    <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>
                </svg>
                ETL Pipeline
            </button>
            <button class="tab-btn" data-tab="queries">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="16 18 22 12 16 6"></polyline>
                    <polyline points="8 6 2 12 8 18"></polyline>
                </svg>
                SQL Queries
            </button>
            <button class="tab-btn" data-tab="api">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M4 11a9 9 0 0 1 9 9"></path>
                    <path d="M4 4a16 16 0 0 1 16 16"></path>
                    <circle cx="5" cy="19" r="1"></circle>
                </svg>
                API Integration
            </button>
            <button class="tab-btn" data-tab="webservice">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                    <line x1="8" y1="21" x2="16" y2="21"></line>
                    <line x1="12" y1="17" x2="12" y2="21"></line>
                </svg>
                Web Services
            </button>
        </div>

        <!-- ETL Pipeline Tab -->
        <div id="etl-tab" class="tab-content active">
            <!-- Pipeline Stage Selector -->
            <div class="pipeline-stages">
                <div class="stage-card active" data-stage="extraction">
                    <div class="stage-card-header">
                        <h3>Salesforce CRM Sync</h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </div>
                    <p>3 error patterns handled</p>
                </div>
                <div class="stage-card" data-stage="transformation">
                    <div class="stage-card-header">
                        <h3>Shopify Order Processing</h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </div>
                    <p>3 error patterns handled</p>
                </div>
                <div class="stage-card" data-stage="loading">
                    <div class="stage-card-header">
                        <h3>Data Warehouse Load</h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </div>
                    <p>3 error patterns handled</p>
                </div>
            </div>

            <!-- Code Display -->
            <div class="code-container">
                <div class="code-header">
                    <span class="code-filename" id="code-filename">extraction.js</span>
                    <span class="code-badge">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                            <polyline points="22 4 12 14.01 9 11.01"></polyline>
                        </svg>
                        Production Ready
                    </span>
                </div>
                <div class="code-block">
                    <pre id="code-display">async function extractData(source) {
  try {
    const connection = await db.connect({
      host: source.host,
      timeout: 30000,
      retries: 3
    });

    const data = await connection.query(
      'SELECT * FROM orders WHERE updated_at > ?',
      [lastSync]
    );

    return { success: true, data, count: data.length };

  } catch (error) {
    if (error.code === 'ETIMEDOUT') {
      await notifySlack('DB timeout - switching to backup');
      return await extractFromBackup(source);
    }

    logError('extraction', error);
    throw new RetryableError(error);
  }
}</pre>
                </div>
            </div>

            <!-- Error Handling Section -->
            <div class="error-section">
                <h3 class="error-section-title">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                    </svg>
                    Error Handling Strategies
                </h3>
                <div class="error-list" id="error-list">
                    <div class="error-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <div class="error-item-content">
                            <div class="error-type">Connection timeout</div>
                            <div class="error-solution">Auto-retry with exponential backoff</div>
                        </div>
                    </div>
                    <div class="error-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <div class="error-item-content">
                            <div class="error-type">Schema mismatch</div>
                            <div class="error-solution">Dynamic field mapping with validation</div>
                        </div>
                    </div>
                    <div class="error-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <div class="error-item-content">
                            <div class="error-type">Data type conflicts</div>
                            <div class="error-solution">Type coercion with fallback defaults</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SQL Queries Tab -->
        <div id="queries-tab" class="tab-content">
            <div class="query-list">
                <div class="query-card">
                    <div class="query-card-header">
                        <h3>Complex Analytics Query</h3>
                        <p>Revenue analysis with error-safe aggregations</p>
                    </div>
                    <div class="code-block">
                        <pre>WITH daily_revenue AS (
  SELECT
    DATE(order_date) as day,
    SUM(COALESCE(amount, 0)) as revenue,
    COUNT(DISTINCT customer_id) as customers,
    -- Handle NULL values safely
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as errors
  FROM orders
  WHERE order_date >= CURRENT_DATE - INTERVAL '90 days'
    AND amount IS NOT NULL  -- Filter invalid data
  GROUP BY DATE(order_date)
)
SELECT
  day,
  revenue,
  customers,
  -- Prevent division by zero
  CASE
    WHEN customers > 0
    THEN revenue / customers
    ELSE 0
  END as avg_per_customer,
  -- Safe percentage calculation
  ROUND(
    100.0 * errors / NULLIF(customers + errors, 0),
    2
  ) as error_rate_pct
FROM daily_revenue
ORDER BY day DESC;</pre>
                    </div>
                </div>

                <div class="query-card">
                    <div class="query-card-header">
                        <h3>Data Quality Check</h3>
                        <p>Validation query with anomaly detection</p>
                    </div>
                    <div class="code-block">
                        <pre>SELECT
  'Null Customer IDs' as issue,
  COUNT(*) as count,
  CURRENT_TIMESTAMP as checked_at
FROM orders
WHERE customer_id IS NULL

UNION ALL

SELECT
  'Negative Amounts' as issue,
  COUNT(*) as count,
  CURRENT_TIMESTAMP
FROM orders
WHERE amount < 0

UNION ALL

SELECT
  'Future Order Dates' as issue,
  COUNT(*) as count,
  CURRENT_TIMESTAMP
FROM orders
WHERE order_date > CURRENT_TIMESTAMP

-- Alert if any issues found
HAVING SUM(count) > 0;</pre>
                    </div>
                </div>

                <div class="query-card">
                    <div class="query-card-header">
                        <h3>Incremental Sync Query</h3>
                        <p>Safe delta extraction with watermarking</p>
                    </div>
                    <div class="code-block">
                        <pre>-- Get last successful sync timestamp
WITH last_sync AS (
  SELECT COALESCE(
    MAX(sync_timestamp),
    TIMESTAMP '2024-01-01'  -- Safe default
  ) as watermark
  FROM etl_metadata
  WHERE pipeline = 'orders'
    AND status = 'success'
)
SELECT
  o.order_id,
  o.customer_id,
  o.amount,
  o.updated_at,
  -- Include metadata for tracking
  CURRENT_TIMESTAMP as extracted_at
FROM orders o
CROSS JOIN last_sync ls
WHERE o.updated_at > ls.watermark
  AND o.updated_at <= CURRENT_TIMESTAMP  -- Prevent clock skew issues
ORDER BY o.updated_at
LIMIT 100000;  -- Prevent memory overflow</pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- API Integration Tab -->
        <div id="api-tab" class="tab-content">
            <!-- API Pattern Selector -->
            <div class="pipeline-stages">
                <div class="stage-card active" data-api="rest-client">
                    <div class="stage-card-header">
                        <h3>Stripe Payments</h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </div>
                    <p>3 error patterns handled</p>
                </div>
                <div class="stage-card" data-api="webhook-handler">
                    <div class="stage-card-header">
                        <h3>Shopify Webhooks</h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </div>
                    <p>3 error patterns handled</p>
                </div>
                <div class="stage-card" data-api="rate-limiter">
                    <div class="stage-card-header">
                        <h3>Inventory Aggregation</h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </div>
                    <p>3 error patterns handled</p>
                </div>
            </div>

            <!-- API Code Display -->
            <div class="code-container">
                <div class="code-header">
                    <span class="code-filename" id="api-code-filename">rest-client.js</span>
                    <span class="code-badge">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                            <polyline points="22 4 12 14.01 9 11.01"></polyline>
                        </svg>
                        Production Ready
                    </span>
                </div>
                <div class="code-block">
                    <pre id="api-code-display">class APIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.timeout = options.timeout || 30000;
    this.retries = options.retries || 3;
    this.backoffMs = options.backoffMs || 1000;
  }

  async request(endpoint, options = {}) {
    let lastError;

    for (let attempt = 1; attempt <= this.retries; attempt++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(
          () => controller.abort(),
          this.timeout
        );

        const response = await fetch(`${this.baseURL}${endpoint}`, {
          ...options,
          signal: controller.signal,
          headers: {
            'Content-Type': 'application/json',
            ...options.headers
          }
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new APIError(response.status, await response.text());
        }

        return await response.json();

      } catch (error) {
        lastError = error;

        if (error.name === 'AbortError') {
          console.warn(`Request timeout, attempt ${attempt}/${this.retries}`);
        }

        if (attempt < this.retries && this.isRetryable(error)) {
          await this.sleep(this.backoffMs * Math.pow(2, attempt - 1));
          continue;
        }

        throw error;
      }
    }
  }

  isRetryable(error) {
    if (error.name === 'AbortError') return true;
    if (error instanceof APIError) {
      return [408, 429, 500, 502, 503, 504].includes(error.status);
    }
    return error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT';
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}</pre>
                </div>
            </div>

            <!-- API Error Handling Section -->
            <div class="error-section">
                <h3 class="error-section-title">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                    </svg>
                    Error Handling Strategies
                </h3>
                <div class="error-list" id="api-error-list">
                    <div class="error-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <div class="error-item-content">
                            <div class="error-type">Network timeouts</div>
                            <div class="error-solution">Exponential backoff with configurable retries</div>
                        </div>
                    </div>
                    <div class="error-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <div class="error-item-content">
                            <div class="error-type">Rate limit exceeded (429)</div>
                            <div class="error-solution">Automatic retry with Retry-After header respect</div>
                        </div>
                    </div>
                    <div class="error-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <div class="error-item-content">
                            <div class="error-type">Server errors (5xx)</div>
                            <div class="error-solution">Circuit breaker pattern with fallback</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Web Services Tab -->
        <div id="webservice-tab" class="tab-content">
            <!-- Web Service Pattern Selector -->
            <div class="pipeline-stages">
                <div class="stage-card active" data-service="express-server">
                    <div class="stage-card-header">
                        <h3>E-commerce Checkout</h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </div>
                    <p>3 error patterns handled</p>
                </div>
                <div class="stage-card" data-service="auth-middleware">
                    <div class="stage-card-header">
                        <h3>Multi-Tenant SaaS</h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </div>
                    <p>3 error patterns handled</p>
                </div>
                <div class="stage-card" data-service="health-monitoring">
                    <div class="stage-card-header">
                        <h3>Real-time Order Tracking</h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </div>
                    <p>3 error patterns handled</p>
                </div>
            </div>

            <!-- Web Service Code Display -->
            <div class="code-container">
                <div class="code-header">
                    <span class="code-filename" id="service-code-filename">server.js</span>
                    <span class="code-badge">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                            <polyline points="22 4 12 14.01 9 11.01"></polyline>
                        </svg>
                        Production Ready
                    </span>
                </div>
                <div class="code-block">
                    <pre id="service-code-display">const express = require('express');
const helmet = require('helmet');
const cors = require('cors');

function createServer(config = {}) {
  const app = express();

  // Security middleware
  app.use(helmet());
  app.use(cors(config.corsOptions));
  app.use(express.json({ limit: '10mb' }));

  // Request ID for tracing
  app.use((req, res, next) => {
    req.id = req.headers['x-request-id'] || crypto.randomUUID();
    res.setHeader('x-request-id', req.id);
    next();
  });

  // Request logging
  app.use((req, res, next) => {
    const start = Date.now();
    res.on('finish', () => {
      logger.info({
        requestId: req.id,
        method: req.method,
        path: req.path,
        status: res.statusCode,
        duration: Date.now() - start
      });
    });
    next();
  });

  // Global error handler
  app.use((err, req, res, next) => {
    const status = err.status || 500;
    const isOperational = err.isOperational || false;

    logger.error({
      requestId: req.id,
      error: err.message,
      stack: isOperational ? undefined : err.stack,
      status
    });

    res.status(status).json({
      error: isOperational ? err.message : 'Internal server error',
      requestId: req.id
    });
  });

  // Graceful shutdown
  const server = app.listen(config.port || 3000);

  process.on('SIGTERM', async () => {
    logger.info('SIGTERM received, shutting down gracefully');
    server.close(() => {
      logger.info('Server closed');
      process.exit(0);
    });
  });

  return { app, server };
}</pre>
                </div>
            </div>

            <!-- Web Service Error Handling Section -->
            <div class="error-section">
                <h3 class="error-section-title">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                    </svg>
                    Error Handling Strategies
                </h3>
                <div class="error-list" id="service-error-list">
                    <div class="error-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <div class="error-item-content">
                            <div class="error-type">Unhandled exceptions</div>
                            <div class="error-solution">Global error handler with structured logging</div>
                        </div>
                    </div>
                    <div class="error-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <div class="error-item-content">
                            <div class="error-type">Process termination</div>
                            <div class="error-solution">Graceful shutdown with connection draining</div>
                        </div>
                    </div>
                    <div class="error-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <div class="error-item-content">
                            <div class="error-type">Request tracing failures</div>
                            <div class="error-solution">Correlation IDs with distributed tracing</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- CTA Section -->
        <div class="cta-section">
            <h3>Like What You See?</h3>
            <p>This is how we build every system. Your project gets the same attention to detail, the same bulletproof error handling, the same production-ready code.</p>
            <div class="cta-buttons">
                <a href="/#schedule" class="btn btn-primary">Schedule a Call</a>
                <a href="/" class="btn btn-outline">Learn More About Us</a>
            </div>
            <p class="cta-note">Feel free to share this page with your technical team for review</p>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        <p>&copy; 2026 SiegeStack. All rights reserved.</p>
        <p style="margin-top: 0.5rem;"><a href="mailto:info@siegestack.com">info@siegestack.com</a> | <a href="/privacy-policy">Privacy Policy</a></p>
    </footer>

    <script>
        // ETL Stage Data
        const etlStages = {
            extraction: {
                filename: 'salesforce-sync.js',
                code: `// Real-world: Syncing Salesforce CRM data to your data warehouse
async function syncSalesforceContacts(lastSyncDate) {
  const sf = new SalesforceClient(process.env.SF_CREDENTIALS);

  // Handle Salesforce API pagination (they limit to 2000 per request)
  let allRecords = [];
  let queryLocator = null;

  do {
    try {
      const result = queryLocator
        ? await sf.queryMore(queryLocator)
        : await sf.query(\`
            SELECT Id, Email, FirstName, LastName, Account.Name,
                   Account.Industry, LeadSource, CreatedDate, LastModifiedDate
            FROM Contact
            WHERE LastModifiedDate > \${lastSyncDate.toISOString()}
            ORDER BY LastModifiedDate ASC
          \`);

      allRecords.push(...result.records);
      queryLocator = result.nextRecordsUrl;

      // Checkpoint progress every 5000 records (resume if job fails)
      if (allRecords.length % 5000 === 0) {
        await saveCheckpoint('sf_contacts', result.records.slice(-1)[0].LastModifiedDate);
      }

    } catch (error) {
      if (error.errorCode === 'REQUEST_LIMIT_EXCEEDED') {
        // Salesforce daily API limit hit - schedule for tomorrow
        await scheduleRetry('sf_contacts', { resumeFrom: queryLocator });
        throw new DeferredError('Salesforce API limit reached');
      }
      throw error;
    }
  } while (queryLocator);

  return { records: allRecords, source: 'salesforce', syncedAt: new Date() };
}`,
                errors: [
                    { type: 'Salesforce API rate limits', solution: 'Checkpoint progress and schedule retry for next day' },
                    { type: 'Session token expiration', solution: 'Auto-refresh OAuth tokens before expiry' },
                    { type: 'Deleted records sync', solution: 'Query Salesforce Recycle Bin for soft deletes' }
                ]
            },
            transformation: {
                filename: 'shopify-orders.js',
                code: `// Real-world: Transforming Shopify orders for financial reporting
function transformShopifyOrder(order) {
  const issues = [];

  // Handle Shopify's nested structure and currency edge cases
  const lineItems = order.line_items.map(item => {
    // Shopify sometimes returns price as string, sometimes number
    const unitPrice = parseFloat(item.price) || 0;
    const quantity = parseInt(item.quantity) || 1;

    // Handle refunded/partially fulfilled items
    const refundedQty = item.refunded_quantity || 0;
    const netQuantity = quantity - refundedQty;

    if (item.variant_id === null) {
      issues.push({ type: 'deleted_product', sku: item.sku, order: order.name });
    }

    return {
      sku: item.sku || \`UNKNOWN-\${item.product_id}\`,
      product_name: item.title,
      unit_price: unitPrice,
      quantity: netQuantity,
      line_total: unitPrice * netQuantity,
      tax: parseFloat(item.tax_lines?.[0]?.price) || 0,
      discount_allocated: parseFloat(item.discount_allocations?.[0]?.amount) || 0
    };
  }).filter(item => item.quantity > 0);

  // Multi-currency handling - convert to base currency
  const exchangeRate = order.currency === 'USD'
    ? 1
    : await getExchangeRate(order.currency, order.created_at);

  return {
    order_id: order.id,
    order_number: order.name,
    customer_email: order.email?.toLowerCase() || order.customer?.email?.toLowerCase(),
    subtotal_usd: parseFloat(order.subtotal_price) * exchangeRate,
    tax_usd: parseFloat(order.total_tax) * exchangeRate,
    shipping_usd: parseFloat(order.shipping_lines?.[0]?.price || 0) * exchangeRate,
    total_usd: parseFloat(order.total_price) * exchangeRate,
    original_currency: order.currency,
    line_items: lineItems,
    source: 'shopify',
    _issues: issues.length > 0 ? issues : null
  };
}`,
                errors: [
                    { type: 'Multi-currency orders', solution: 'Historical exchange rate lookup with fallback' },
                    { type: 'Deleted product variants', solution: 'Flag for review, use SKU as fallback identifier' },
                    { type: 'Partial refunds mid-sync', solution: 'Recalculate line totals, emit adjustment records' }
                ]
            },
            loading: {
                filename: 'warehouse-load.js',
                code: `// Real-world: Loading data into Snowflake/BigQuery with CDC
async function loadToWarehouse(records, config) {
  const warehouse = new WarehouseClient(config.connection);
  const stagingTable = \`staging_\${config.table}_\${Date.now()}\`;
  const results = { inserted: 0, updated: 0, failed: 0, errors: [] };

  try {
    // 1. Bulk load to staging table (fast - no constraints)
    await warehouse.createTempTable(stagingTable, config.schema);
    await warehouse.bulkLoad(stagingTable, records, { format: 'JSON' });

    // 2. Merge into production with proper CDC handling
    const mergeResult = await warehouse.execute(\`
      MERGE INTO \${config.table} AS target
      USING \${stagingTable} AS source
      ON target.\${config.primaryKey} = source.\${config.primaryKey}

      WHEN MATCHED AND source._deleted = true THEN
        UPDATE SET _deleted_at = CURRENT_TIMESTAMP, _active = false

      WHEN MATCHED AND source._updated_at > target._updated_at THEN
        UPDATE SET \${config.columns.map(c => \`\${c} = source.\${c}\`).join(', ')},
                   _updated_at = CURRENT_TIMESTAMP,
                   _version = target._version + 1

      WHEN NOT MATCHED THEN
        INSERT (\${config.columns.join(', ')}, _created_at, _version)
        VALUES (\${config.columns.map(c => \`source.\${c}\`).join(', ')}, CURRENT_TIMESTAMP, 1)
    \`);

    results.inserted = mergeResult.rowsInserted;
    results.updated = mergeResult.rowsUpdated;

    // 3. Update high-water mark for next incremental sync
    await warehouse.execute(\`
      UPDATE etl_watermarks
      SET last_value = (SELECT MAX(_source_updated_at) FROM \${stagingTable}),
          last_run = CURRENT_TIMESTAMP,
          records_processed = \${records.length}
      WHERE pipeline = '\${config.pipeline}'
    \`);

  } catch (error) {
    if (error.code === 'WAREHOUSE_SUSPENDED') {
      await warehouse.resume();
      return loadToWarehouse(records, config); // Retry after resume
    }
    throw error;
  } finally {
    await warehouse.dropTable(stagingTable);
  }

  return results;
}`,
                errors: [
                    { type: 'Warehouse auto-suspend', solution: 'Detect suspended state, auto-resume before retry' },
                    { type: 'Schema drift', solution: 'Dynamic column detection with ALTER TABLE' },
                    { type: 'Duplicate key on merge', solution: 'Dedup in staging before merge, keep latest version' }
                ]
            }
        };

        // API Stage Data
        const apiStages = {
            'rest-client': {
                filename: 'stripe-payments.js',
                code: `// Real-world: Processing payments with Stripe (handling all the edge cases)
async function processPayment(order, paymentMethod) {
  const idempotencyKey = \`order_\${order.id}_\${order.updated_at}\`;

  try {
    // 1. Create or retrieve customer (handle guest checkout)
    let customer;
    if (order.customer_id) {
      customer = await stripe.customers.retrieve(order.stripe_customer_id);
    } else {
      customer = await stripe.customers.create({
        email: order.email,
        metadata: { guest: true, order_id: order.id }
      }, { idempotencyKey: \`customer_\${idempotencyKey}\` });
    }

    // 2. Create PaymentIntent with proper error handling
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(order.total * 100), // Stripe uses cents
      currency: order.currency.toLowerCase(),
      customer: customer.id,
      payment_method: paymentMethod.id,
      confirm: true,
      metadata: {
        order_id: order.id,
        order_number: order.number
      },
      // Handle 3D Secure / SCA requirements
      return_url: \`\${process.env.APP_URL}/orders/\${order.id}/confirm\`,
    }, { idempotencyKey });

    // 3. Handle various payment states
    if (paymentIntent.status === 'requires_action') {
      return {
        success: false,
        requires_action: true,
        client_secret: paymentIntent.client_secret,
        message: 'Additional authentication required'
      };
    }

    if (paymentIntent.status === 'succeeded') {
      await db.orders.update(order.id, {
        payment_status: 'paid',
        stripe_payment_id: paymentIntent.id,
        paid_at: new Date()
      });
      await triggerFulfillment(order.id);
      return { success: true, payment_id: paymentIntent.id };
    }

    throw new PaymentError(\`Unexpected status: \${paymentIntent.status}\`);

  } catch (error) {
    // Stripe-specific error handling
    if (error.type === 'StripeCardError') {
      return { success: false, error: error.message, code: error.decline_code };
    }
    if (error.type === 'StripeInvalidRequestError') {
      logger.error('Stripe config error', { error, order_id: order.id });
      throw error; // This is a bug, not a user error
    }
    throw error;
  }
}`,
                errors: [
                    { type: 'Card declined', solution: 'Return user-friendly message with decline code' },
                    { type: '3D Secure required', solution: 'Return client_secret for frontend authentication flow' },
                    { type: 'Duplicate charges', solution: 'Idempotency keys prevent double-charging on retries' }
                ]
            },
            'webhook-handler': {
                filename: 'shopify-webhooks.js',
                code: `// Real-world: Processing Shopify order webhooks for fulfillment system
async function handleShopifyOrderWebhook(req, res) {
  // CRITICAL: Respond quickly - Shopify times out after 5 seconds
  // Process async, acknowledge immediately
  const webhookId = req.headers['x-shopify-webhook-id'];
  const topic = req.headers['x-shopify-topic'];
  const shop = req.headers['x-shopify-shop-domain'];

  // 1. Verify webhook is from Shopify (prevent spoofing)
  const hmac = req.headers['x-shopify-hmac-sha256'];
  const verified = crypto.timingSafeEqual(
    Buffer.from(hmac),
    Buffer.from(
      crypto.createHmac('sha256', process.env.SHOPIFY_WEBHOOK_SECRET)
        .update(req.rawBody)
        .digest('base64')
    )
  );

  if (!verified) {
    logger.warn('Invalid Shopify webhook signature', { shop, topic });
    return res.status(401).send('Invalid signature');
  }

  // 2. Idempotency - Shopify retries, don't double-process
  const existing = await redis.get(\`webhook:\${webhookId}\`);
  if (existing) {
    return res.status(200).send('Already processed');
  }
  await redis.set(\`webhook:\${webhookId}\`, 'processing', 'EX', 86400);

  // 3. Acknowledge immediately, process async
  res.status(200).send('Accepted');

  // 4. Now handle the actual business logic
  try {
    const order = req.body;

    if (topic === 'orders/create') {
      // Check inventory across multiple warehouses
      const inventoryCheck = await checkMultiWarehouseInventory(order.line_items);

      if (inventoryCheck.canFulfill) {
        await createFulfillmentOrder(order, inventoryCheck.warehouse);
        await updateShopifyFulfillment(shop, order.id, 'in_progress');
      } else {
        // Backorder flow
        await createBackorder(order, inventoryCheck.shortages);
        await notifyCustomerServiceTeam(order, 'inventory_shortage');
      }
    }

    if (topic === 'orders/cancelled') {
      await cancelFulfillmentIfNotShipped(order.id);
      await restoreInventory(order.line_items);
    }

    await redis.set(\`webhook:\${webhookId}\`, 'completed', 'EX', 86400);

  } catch (error) {
    await redis.set(\`webhook:\${webhookId}\`, 'failed', 'EX', 86400);
    await deadLetterQueue.add({ webhookId, error: error.message, payload: req.body });
  }
}`,
                errors: [
                    { type: 'Shopify 5-second timeout', solution: 'Acknowledge immediately, process asynchronously' },
                    { type: 'Duplicate webhook deliveries', solution: 'Idempotency check with Redis TTL' },
                    { type: 'Multi-store webhook routing', solution: 'Extract shop domain, route to correct tenant' }
                ]
            },
            'rate-limiter': {
                filename: 'inventory-aggregator.js',
                code: `// Real-world: Aggregating inventory from multiple vendors/warehouses
async function getUnifiedInventory(sku) {
  const vendors = [
    { name: 'warehouse_east', api: new WarehouseAPI('east'), priority: 1 },
    { name: 'warehouse_west', api: new WarehouseAPI('west'), priority: 2 },
    { name: 'supplier_acme', api: new SupplierAPI('acme'), priority: 3 },
    { name: 'dropship_partner', api: new DropshipAPI(), priority: 4 }
  ];

  // Query all sources in parallel with individual timeouts
  const results = await Promise.allSettled(
    vendors.map(async (vendor) => {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 5000);

      try {
        const inventory = await vendor.api.checkStock(sku, {
          signal: controller.signal
        });

        return {
          vendor: vendor.name,
          priority: vendor.priority,
          available: inventory.quantity,
          reserved: inventory.reserved || 0,
          inbound: inventory.incoming_shipments || 0,
          updated_at: inventory.last_updated
        };
      } finally {
        clearTimeout(timeout);
      }
    })
  );

  // Process results - handle partial failures gracefully
  const inventory = { sources: [], totalAvailable: 0, errors: [] };

  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      inventory.sources.push(result.value);
      inventory.totalAvailable += Math.max(0, result.value.available - result.value.reserved);
    } else {
      // Log failure but don't fail the whole request
      inventory.errors.push({
        vendor: vendors[index].name,
        error: result.reason.message
      });
      logger.warn(\`Inventory check failed for \${vendors[index].name}\`, {
        sku, error: result.reason.message
      });
    }
  });

  // Sort by priority for fulfillment routing
  inventory.sources.sort((a, b) => a.priority - b.priority);

  // Add recommendation for fulfillment
  inventory.recommendedSource = inventory.sources.find(s => s.available > s.reserved);
  inventory.canFulfill = inventory.totalAvailable > 0;
  inventory.isPartialData = inventory.errors.length > 0;

  // Cache result briefly (inventory changes frequently)
  await redis.setex(\`inventory:\${sku}\`, 30, JSON.stringify(inventory));

  return inventory;
}`,
                errors: [
                    { type: 'Vendor API timeout', solution: 'Individual timeouts with Promise.allSettled for partial results' },
                    { type: 'Inconsistent data formats', solution: 'Normalize responses with vendor-specific adapters' },
                    { type: 'Stale inventory data', solution: 'Short TTL cache with staleness indicator for UI' }
                ]
            }
        };

        // Web Service Stage Data
        const serviceStages = {
            'express-server': {
                filename: 'checkout-api.js',
                code: `// Real-world: E-commerce checkout with inventory reservation
app.post('/api/checkout', authenticate, async (req, res) => {
  const { cart_id, shipping_address, payment_method } = req.body;
  const checkoutId = crypto.randomUUID();

  try {
    // 1. Validate cart hasn't changed since user started checkout
    const cart = await Cart.findById(cart_id);
    if (cart.version !== req.body.cart_version) {
      return res.status(409).json({
        error: 'Cart was modified',
        code: 'CART_CHANGED',
        current_version: cart.version
      });
    }

    // 2. Reserve inventory with timeout (hold for 10 minutes)
    const reservation = await inventoryService.reserve({
      items: cart.items,
      checkout_id: checkoutId,
      expires_at: new Date(Date.now() + 10 * 60 * 1000)
    });

    if (!reservation.success) {
      return res.status(400).json({
        error: 'Some items are no longer available',
        code: 'INVENTORY_UNAVAILABLE',
        unavailable_items: reservation.failures
      });
    }

    // 3. Calculate final totals (tax, shipping, discounts)
    const totals = await pricingService.calculate({
      items: cart.items,
      shipping_address,
      customer_id: req.user.id,
      coupon_code: cart.coupon_code
    });

    // 4. Process payment (in try/finally to ensure inventory release on failure)
    try {
      const payment = await paymentService.charge({
        amount: totals.grand_total,
        currency: totals.currency,
        payment_method,
        metadata: { checkout_id: checkoutId, customer_id: req.user.id }
      });

      // 5. Create order (payment succeeded)
      const order = await Order.create({
        checkout_id: checkoutId,
        customer_id: req.user.id,
        items: cart.items,
        totals,
        payment_id: payment.id,
        shipping_address,
        status: 'confirmed'
      });

      // 6. Commit inventory reservation
      await inventoryService.commitReservation(checkoutId);

      // 7. Trigger async processes (don't block response)
      eventBus.emit('order.created', { order_id: order.id });

      return res.status(201).json({ order_id: order.id, order_number: order.number });

    } catch (paymentError) {
      // Payment failed - release inventory reservation
      await inventoryService.releaseReservation(checkoutId);
      throw paymentError;
    }

  } catch (error) {
    logger.error('Checkout failed', { checkoutId, error: error.message });
    throw error;
  }
});`,
                errors: [
                    { type: 'Cart modified during checkout', solution: 'Optimistic locking with version check' },
                    { type: 'Inventory sold out mid-checkout', solution: 'Temporary reservation with auto-release timeout' },
                    { type: 'Payment fails after inventory reserved', solution: 'Release reservation in catch block' }
                ]
            },
            'auth-middleware': {
                filename: 'multi-tenant.js',
                code: `// Real-world: Multi-tenant SaaS with organization scoping
async function tenantMiddleware(req, res, next) {
  try {
    // 1. Extract tenant from subdomain or header
    const tenantSlug = req.subdomains[0] || req.headers['x-tenant-id'];

    if (!tenantSlug) {
      return res.status(400).json({ error: 'Tenant not specified' });
    }

    // 2. Load tenant config (cached)
    const tenant = await getTenantBySlug(tenantSlug);

    if (!tenant) {
      return res.status(404).json({ error: 'Tenant not found' });
    }

    if (tenant.status === 'suspended') {
      return res.status(403).json({
        error: 'Account suspended',
        reason: tenant.suspension_reason,
        contact: 'billing@yourapp.com'
      });
    }

    // 3. Verify user belongs to this tenant
    if (req.user && !req.user.tenant_ids.includes(tenant.id)) {
      logger.warn('Cross-tenant access attempt', {
        user_id: req.user.id,
        attempted_tenant: tenant.id,
        user_tenants: req.user.tenant_ids
      });
      return res.status(403).json({ error: 'Access denied to this organization' });
    }

    // 4. Set up tenant-scoped database connection
    req.tenant = tenant;
    req.db = createTenantConnection(tenant.database_schema);

    // 5. Apply tenant-specific feature flags
    req.features = await getFeatureFlags(tenant.plan, tenant.feature_overrides);

    // 6. Set tenant context for logging and auditing
    logger.setContext({ tenant_id: tenant.id, tenant_name: tenant.name });

    next();
  } catch (error) {
    next(error);
  }
}

// Ensure queries never leak data between tenants
function scopeToTenant(model) {
  return {
    find: (query) => model.find({ ...query, tenant_id: req.tenant.id }),
    create: (data) => model.create({ ...data, tenant_id: req.tenant.id }),
    update: (id, data) => model.update(
      { _id: id, tenant_id: req.tenant.id }, // Always include tenant_id!
      data
    ),
    delete: (id) => model.delete({ _id: id, tenant_id: req.tenant.id })
  };
}`,
                errors: [
                    { type: 'Cross-tenant data leaks', solution: 'Always scope queries with tenant_id, audit access attempts' },
                    { type: 'Suspended account access', solution: 'Check tenant status before processing requests' },
                    { type: 'User accessing wrong tenant', solution: 'Verify user membership, log suspicious attempts' }
                ]
            },
            'health-monitoring': {
                filename: 'order-tracking.js',
                code: `// Real-world: Real-time order tracking with WebSocket updates
class OrderTrackingService {
  constructor(io) {
    this.io = io;
    this.activeTrackers = new Map(); // order_id -> Set of socket ids
  }

  // Customer subscribes to order updates
  async subscribeToOrder(socket, orderId) {
    // Verify customer owns this order
    const order = await Order.findById(orderId);
    if (!order || order.customer_id !== socket.user.id) {
      socket.emit('error', { code: 'ORDER_NOT_FOUND' });
      return;
    }

    // Add to tracking room
    socket.join(\`order:\${orderId}\`);

    if (!this.activeTrackers.has(orderId)) {
      this.activeTrackers.set(orderId, new Set());
    }
    this.activeTrackers.get(orderId).add(socket.id);

    // Send current status immediately
    socket.emit('order:status', await this.getOrderStatus(orderId));

    // Clean up on disconnect
    socket.on('disconnect', () => {
      this.activeTrackers.get(orderId)?.delete(socket.id);
      if (this.activeTrackers.get(orderId)?.size === 0) {
        this.activeTrackers.delete(orderId);
      }
    });
  }

  // Called by fulfillment system when order status changes
  async broadcastUpdate(orderId, update) {
    const status = await this.getOrderStatus(orderId);

    // Push to all connected customers watching this order
    this.io.to(\`order:\${orderId}\`).emit('order:status', status);

    // Also send push notification for important updates
    if (['shipped', 'out_for_delivery', 'delivered'].includes(update.status)) {
      const order = await Order.findById(orderId);
      await pushNotificationService.send(order.customer_id, {
        title: this.getNotificationTitle(update.status),
        body: update.message,
        data: { order_id: orderId, status: update.status }
      });
    }

    // Log for analytics
    await EventLog.create({
      type: 'order_status_change',
      order_id: orderId,
      old_status: update.previous_status,
      new_status: update.status,
      source: update.source, // 'warehouse', 'carrier', 'system'
      timestamp: new Date()
    });
  }

  async getOrderStatus(orderId) {
    const [order, shipments, timeline] = await Promise.all([
      Order.findById(orderId),
      Shipment.findByOrderId(orderId),
      OrderTimeline.findByOrderId(orderId)
    ]);

    return {
      order_number: order.number,
      status: order.status,
      shipments: shipments.map(s => ({
        carrier: s.carrier,
        tracking_number: s.tracking_number,
        tracking_url: s.tracking_url,
        status: s.status,
        estimated_delivery: s.estimated_delivery,
        last_location: s.last_location
      })),
      timeline: timeline.map(t => ({
        status: t.status,
        message: t.message,
        timestamp: t.created_at
      })),
      updated_at: order.updated_at
    };
  }
}`,
                errors: [
                    { type: 'WebSocket disconnections', solution: 'Auto-reconnect with exponential backoff, room-based cleanup' },
                    { type: 'Unauthorized order access', solution: 'Verify ownership before subscribing to updates' },
                    { type: 'Missed updates during reconnect', solution: 'Send full current state on subscription' }
                ]
            }
        };

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const tab = this.dataset.tab;

                // Update button states
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');

                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById(tab + '-tab').classList.add('active');
            });
        });

        // Stage switching
        function updateStage(stage) {
            const data = etlStages[stage];

            // Update active state
            document.querySelectorAll('.stage-card').forEach(card => {
                card.classList.toggle('active', card.dataset.stage === stage);
            });

            // Update code display
            document.getElementById('code-filename').textContent = data.filename;
            document.getElementById('code-display').textContent = data.code;

            // Update error list
            const errorList = document.getElementById('error-list');
            errorList.innerHTML = data.errors.map(error => `
                <div class="error-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <div class="error-item-content">
                        <div class="error-type">${error.type}</div>
                        <div class="error-solution">${error.solution}</div>
                    </div>
                </div>
            `).join('');
        }

        document.querySelectorAll('.stage-card[data-stage]').forEach(card => {
            card.addEventListener('click', function() {
                updateStage(this.dataset.stage);
            });
        });

        // API Stage switching
        function updateApiStage(stage) {
            const data = apiStages[stage];

            // Update active state for API cards only
            document.querySelectorAll('.stage-card[data-api]').forEach(card => {
                card.classList.toggle('active', card.dataset.api === stage);
            });

            // Update code display
            document.getElementById('api-code-filename').textContent = data.filename;
            document.getElementById('api-code-display').textContent = data.code;

            // Update error list
            const errorList = document.getElementById('api-error-list');
            errorList.innerHTML = data.errors.map(error => `
                <div class="error-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <div class="error-item-content">
                        <div class="error-type">${error.type}</div>
                        <div class="error-solution">${error.solution}</div>
                    </div>
                </div>
            `).join('');
        }

        document.querySelectorAll('.stage-card[data-api]').forEach(card => {
            card.addEventListener('click', function() {
                updateApiStage(this.dataset.api);
            });
        });

        // Web Service Stage switching
        function updateServiceStage(stage) {
            const data = serviceStages[stage];

            // Update active state for service cards only
            document.querySelectorAll('.stage-card[data-service]').forEach(card => {
                card.classList.toggle('active', card.dataset.service === stage);
            });

            // Update code display
            document.getElementById('service-code-filename').textContent = data.filename;
            document.getElementById('service-code-display').textContent = data.code;

            // Update error list
            const errorList = document.getElementById('service-error-list');
            errorList.innerHTML = data.errors.map(error => `
                <div class="error-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <div class="error-item-content">
                        <div class="error-type">${error.type}</div>
                        <div class="error-solution">${error.solution}</div>
                    </div>
                </div>
            `).join('');
        }

        document.querySelectorAll('.stage-card[data-service]').forEach(card => {
            card.addEventListener('click', function() {
                updateServiceStage(this.dataset.service);
            });
        });

        // Mobile menu toggle
        document.querySelector('.mobile-menu-btn').addEventListener('click', function() {
            const links = document.querySelector('.nav-links');
            if (links.style.display === 'flex') {
                links.style.display = 'none';
            } else {
                links.style.display = 'flex';
                links.style.flexDirection = 'column';
                links.style.position = 'absolute';
                links.style.top = '100%';
                links.style.left = '0';
                links.style.right = '0';
                links.style.background = 'rgba(10, 25, 47, 0.98)';
                links.style.padding = '1rem';
                links.style.gap = '1rem';
            }
        });
    </script>
</body>
</html>
